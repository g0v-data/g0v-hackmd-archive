# chapter9
**檔案系統 (File System)** 是作業系統的一個重要組成部分，用來管理和組織儲存裝置上的數據。以下是關於檔案系統的主要概念和結構的繁體中文解釋：  

---

### **介面 (Interface)**  
檔案系統提供一個介面，讓使用者或應用程式能方便地存取儲存裝置上的數據，而不需要了解底層的物理儲存細節。

---

### **檔案概念 (File Concept)**  
- **檔案** 是由作業系統創建的一個邏輯儲存單元，用來儲存數據或程式。  
- 與磁碟上的**物理儲存單元**（如磁軌、磁區）不同，檔案是使用者可理解的數據結構。  
- **檔案類型：**  
  1. **數據檔案 (Data File)：** 儲存文字、圖片、音訊等資料。  
  2. **程式檔案 (Program File)：** 儲存執行的指令或程式碼。  
- **內容：** 檔案的具體內容由檔案的創建者決定。

---

### **存取方法 (Access Methods)**  
- 提供不同的方式來讀取或寫入檔案，例如：  
  1. **順序存取 (Sequential Access)：** 依次從頭到尾存取檔案內容。  
  2. **隨機存取 (Random Access)：** 可以直接跳到檔案的某個位置進行操作。

---

### **目錄結構 (Directory Structure)**  
- 用來組織和管理檔案的結構，類似於樹狀結構：  
  - **單層目錄 (Single-Level Directory)：** 所有檔案都儲存在一個目錄中。  
  - **雙層目錄 (Two-Level Directory)：** 每個使用者有自己專屬的目錄。  
  - **分層目錄 (Hierarchical Directory)：** 允許子目錄的存在，形成樹狀結構。  

---

### **檔案系統掛載 (File-System Mounting)**  
- 將檔案系統與作業系統關聯，使得特定的儲存裝置（如磁碟分區）可被使用。  
- **掛載點 (Mount Point)：** 檔案系統與目錄結構相連的地方。

---

### **檔案共享 (File Sharing)**  
- 多個使用者或系統可以同時存取同一檔案。  
- 可能面臨的挑戰：  
  1. 存取控制權限的設定。  
  2. 資料同步問題。

---

### **保護 (Protection)**  
- 防止未經授權的使用者存取或修改檔案。  
- 常用機制：  
  1. **存取控制 (Access Control)：** 設定誰可以讀取、寫入或執行檔案。  
  2. **加密 (Encryption)：** 保護檔案內容免受惡意攻擊。

---

### **實現方式 (Implementation)**  
#### **檔案系統結構 (File-System Structure)**  
- 檔案系統由多層結構組成：  
  1. 使用者層：提供介面。  
  2. 邏輯層：負責檔案與磁碟的邏輯映射。  
  3. 物理層：管理實際的磁碟空間。  

#### **檔案系統實現 (File-System Implementation)**  
- 涉及如何儲存、檢索和管理檔案的元數據及實際數據。  

---

### **配置方式 (Allocation Methods)**  
- 確定如何將磁碟空間分配給檔案：  
  1. **連續配置 (Contiguous Allocation)：** 檔案的所有區塊連續存放。  
  2. **連結配置 (Linked Allocation)：** 每個區塊保存下一區塊的指標。  
  3. **索引配置 (Indexed Allocation)：** 使用索引節點來記錄檔案的所有區塊位置。  

---

### **空間管理 (Free-Space Management)**  
- 負責追蹤磁碟上未使用的空間：  
  1. **位元圖法 (Bit Vector)：** 用位元表示每個區塊的使用狀態。  
  2. **連結法 (Linked List)：** 使用鏈表記錄空閒區塊。  
  3. **群集法 (Grouping)：** 將空閒區塊分組儲存。  

--- 

透過上述機制，檔案系統能有效率地管理儲存裝置，滿足使用者的需求並保證資料的安全性和一致性。

### **檔案屬性 (File Attributes)**  
檔案的屬性是用來描述檔案的特徵及其相關資訊。以下是主要屬性：  

1. **名稱 (Name)：**  
   - 人類可讀的唯一名稱，用來標識檔案。  
2. **識別碼 (Identifier)：**  
   - 一個唯一的標籤（通常是數字），用來在檔案系統中識別該檔案。  
3. **類型 (Type)：**  
   - 系統需要此資訊來支援不同類型的檔案，例如文字檔案、執行檔案或多媒體檔案。  
4. **位置 (Location)：**  
   - 檔案在儲存裝置上的位址指標，用於定位檔案的實際存放位置。  
5. **大小 (Size)：**  
   - 檔案的當前大小（通常以位元組為單位）。  
6. **保護 (Protection)：**  
   - 控制檔案的存取權限，例如誰可以讀取、寫入或執行該檔案。  
7. **時間、日期及使用者識別 (Time, Date, and User Identification)：**  
   - 用於保護、記錄檔案的安全性以及監控其使用情況。  

---

### **檔案操作 (File Operations)**  
檔案系統允許使用者或程式進行各種操作。以下是常見的檔案操作：  

1. **建立 (Create)：**  
   - 建立一個新檔案並分配空間給它。  
2. **寫入 (Write)：**  
   - 從**寫入指標 (Write Pointer)** 所在的位置向檔案寫入數據。  
3. **讀取 (Read)：**  
   - 從**讀取指標 (Read Pointer)** 所在的位置讀取檔案的內容。  
4. **重新定位 (Reposition Within File, Seek)：**  
   - 將讀寫指標移動到檔案的不同位置，方便進行隨機存取。  
5. **刪除 (Delete)：**  
   - 從檔案系統中移除檔案，並釋放其佔用的儲存空間。  
6. **截斷/連接 (Truncate/Concatenate)：**  
   - **截斷 (Truncate)：** 刪除檔案的部分內容，使其縮小到指定大小。  
   - **連接 (Concatenate)：** 將另一個檔案的內容附加到當前檔案後。  

---

### **作業流程與表格管理**  

1. **處理：開檔表 (Process: Open-File Table)**  
   - 每個進程有一個專屬的**開檔表**，記錄該進程當前開啟的檔案及其相關資訊（例如指標位置、權限等）。  

2. **作業系統：全域檔案表 (Global File Table)**  
   - 作業系統維護一個**全域檔案表**，用來記錄所有正在被系統使用的檔案，包括開啟次數、檔案屬性等共享資訊。  

--- 

這些操作和屬性確保檔案系統能有效地管理檔案，同時為使用者提供便利性與安全性。

### **開檔表 (Open-File Tables)**  

檔案系統使用開檔表來管理進程和系統中已開啟的檔案，分為**每個進程的開檔表**和**系統範圍的全域開檔表**：  

#### **1. 每個進程的開檔表 (Per-Process Open-File Table)**  
- 每個進程維護自己的開檔表，用來追蹤該進程所開啟的所有檔案。  
- 每個開檔表條目包括：  
  1. **當前檔案指標 (Current File Pointer)：** 指示檔案操作的當前位置，例如讀寫的起點。  
  2. **存取權限 (Access Rights)：** 定義進程對檔案的存取類型（讀取、寫入、執行）。  
  3. **記錄資訊 (Accounting Information)：** 用於跟蹤與該檔案相關的操作細節。  

#### **2. 系統範圍的開檔表 (System-Wide Open-File Table)**  
- 作業系統維護一個全域的開檔表，儲存所有目前開啟檔案的進程無關資訊。  
- 每個進程的開檔表條目會指向系統範圍的開檔表，便於共享與管理。  
- 全域開檔表的內容包括：  
  1. **磁碟位置 (Disk Location)：** 檔案在儲存裝置上的位址。  
  2. **存取日期 (Access Dates)：** 記錄檔案最近的使用日期和時間。  
  3. **檔案大小 (File Size)：** 紀錄檔案的總大小。  
  4. **開啟次數 (Open Count)：** 追蹤檔案被多少進程同時開啟，用於決定檔案的關閉時機。

---

### **存取方法 (Access Methods)**  

檔案系統支援不同的存取方式來操作檔案數據，以下是三種主要存取方法的解釋：  

#### **1. 順序存取 (Sequential Access)**  
- 按照固定的順序依次讀取或寫入檔案的數據。  
- **操作：**  
  1. **讀取/寫入下一區塊 (Read/Write Next Block)：** 讀取或寫入當前指標位置的下一筆記錄。  
  2. **重置 (Reset)：** 將檔案指標重定位到檔案開頭。  
  3. **跳過/倒帶 n 筆記錄 (Skip/Rewind n Records)：** 直接跳過或返回特定數量的記錄。  
- **例子：** 類似於操作錄影帶或磁帶，需按順序快進或倒帶來存取資料。  

---

#### **2. 直接存取 (Direct Access)**  
- 又稱相對存取 (Relative Access)，允許直接存取檔案中的任意位置。  
- **操作：**  
  - 使用檔案區塊號 (Block #) 作為參數，指定位於檔案中的目標數據位置。  
- **特點：**  
  - 更靈活，適合需要快速定位檔案特定部分的應用。  
  - 此方法通常也被稱為隨機存取 (Random Access)，因為存取模式的隨機性與直接定位能力。  

---

#### **3. 索引存取 (Index Access)**  
- 利用索引結構來快速定位檔案中的數據區塊。  
- **操作流程：**  
  1. **搜尋索引檔案 (Search the Index File)：** 找到目標數據的指標 (Pointer)。  
  2. **利用指標 (Use the Pointer)：** 根據指標直接存取數據區塊。  
- **特點：**  
  - 適用於大型檔案，特別是在需要頻繁查找特定記錄的情況下。  
  - 如果檔案過大，索引本身可能會變得過於龐大，影響效能。  

---

這些存取方法提供了不同的彈性與效率，根據應用需求選擇適合的方式可以優化檔案系統的效能和操作體驗。

### **目錄結構 (Directory Structure)**  

目錄結構是檔案系統的一部分，用來組織和管理儲存裝置中的檔案及其相關資訊。以下是關於目錄結構的主要特點：  

1. **節點集合 (Collection of Nodes)：**  
   - 目錄結構由多個節點組成，每個節點儲存有關檔案的資訊，例如名稱、位置、大小和屬性等。  

2. **存放位置 (Resides on Disk)：**  
   - 目錄結構和檔案一樣，都是存放在磁碟中的，確保它們在系統重新啟動後仍能被訪問。  
https://hackmd.io/@Chang-Chia-Chi/OS-CH11
---

### **目錄操作 (Directory Operations)**  

目錄結構提供了一系列操作，用於管理檔案和目錄：  

1. **搜尋檔案 (Search for a File)：**  
   - 用於在目錄中查找特定檔案的資訊或其位置。  

2. **建立檔案 (Create a File)：**  
   - 在目錄中新增一個新的檔案節點，並為其分配儲存空間。  

3. **刪除檔案 (Delete a File)：**  
   - 從目錄結構中移除檔案的節點，並釋放其佔用的磁碟空間。  

4. **列出目錄 (List a Directory)：**  
   - 顯示目錄中的所有檔案和子目錄名稱。  

5. **重新命名檔案 (Rename a File)：**  
   - 修改目錄中檔案的名稱，保持其內容和屬性不變。  

6. **遍歷檔案系統 (Traverse the File System)：**  
   - 瀏覽整個檔案系統，按層次結構檢視目錄和檔案，通常用於檔案管理或備份。  

---  

透過這些功能，目錄結構可以有效地組織和管理檔案系統中的數據，提供便捷的檔案操作和存取方式。

### **單層目錄結構 (Single-Level Directory)**  

單層目錄是最簡單的目錄結構，其中所有使用者的檔案都存放在同一個目錄中。其特性與問題包括：  

1. **特性：**  
   - 單一目錄中包含所有使用者的檔案，沒有分層或分類的概念。  

2. **問題：**  
   - **命名問題 (Naming Problem)：**  
     - 檔案名稱必須是唯一的，因為所有檔案都在同一個目錄中，這可能導致命名衝突。  
   - **分組問題 (Grouping Problem)：**  
     - 由於缺乏子目錄結構，無法對檔案進行分類，例如無法將工作檔案與個人檔案分開。  
   - **效率低下 (Poor Efficiency)：**  
     - 當檔案數量增加時，搜尋和管理檔案變得困難且低效。

---

### **雙層目錄結構 (Two-Level Directory)**  

雙層目錄為每個使用者提供獨立的目錄，解決了部分單層目錄的問題：  

1. **特性：**  
   - 每位使用者都有自己專屬的目錄，目錄中可以包含該使用者的所有檔案。  
   - **路徑名稱 (Path Name)：**  
     - 檔案的位置由**使用者名稱 + 檔案名稱**組成，明確表示檔案歸屬。  

2. **優點：**  
   - **檔案名稱可重複：** 不同使用者可以擁有相同名稱的檔案，避免命名衝突。  
   - **搜尋效率提升：** 每位使用者的檔案獨立管理，搜尋範圍變小。  

3. **缺點：**  
   - **無分組能力：** 目錄仍然是平面的，缺乏子目錄的分層結構，使用者無法進一步對檔案分類。  
   - 單層目錄的問題在每個使用者目錄內仍然存在，例如目錄內檔案過多時搜尋效率降低。

---

### **樹狀目錄結構 (Tree-Structured Directory)**  

樹狀目錄結構是更複雜且靈活的目錄結構，允許建立子目錄以組織檔案。  

1. **特性：**  
   - 目錄結構呈現樹狀，每個目錄可以包含檔案或子目錄。  
   - 支援兩種類型的路徑：  
     - **絕對路徑 (Absolute Path)：** 從根目錄開始，例如 `/spell/mail/prt/first`。  
     - **相對路徑 (Relative Path)：** 從當前目錄開始，例如 `/prt/first`。  

2. **操作範例：**  
   - 當前目錄為 `/mail` 時：  
     - **建立新目錄：** 使用 `mkdir count` 命令在 `/mail` 下建立名為 `count` 的子目錄。  
     - **刪除目錄：** 如果刪除 `/mail`，則整個以 `/mail` 為根的子樹（包括其所有子目錄與檔案）都會被刪除。  

3. **優點：**  
   - **搜尋效率高：** 目錄結構清晰，檔案和目錄容易定位。  
   - **分組能力：** 支援子目錄結構，方便對檔案進行分類和分組管理。  

---

樹狀目錄結構彌補了單層和雙層目錄的不足，提供了更強大的組織能力和操作靈活性，是現代檔案系統的主流設計。

### **無環圖目錄結構 (Acyclic-Graph Directory)**  

無環圖目錄是一種目錄結構，其中不允許目錄之間形成循環。其特性與問題包括：  

1. **特性：**  
   - **無循環 (No Loop)：** 目錄結構中沒有環路，避免無限循環的問題。  
   - **共享目錄與檔案 (Shared Directories and Files)：** 支援多個使用者或項目共享檔案或目錄，例如聯合項目中的資源共享。  
   - **多重絕對路徑 (Multiple Absolute Paths)：** 一個檔案可能有多個不同的絕對路徑，因為它可以被多個目錄指向。  

2. **刪除檔案的問題：**  
   - **刪除連結但不刪檔案：**  
     - 如果只刪除某個目錄中的檔案連結，但檔案仍有其他連結存在，檔案不會被刪除。  
   - **刪除檔案但不刪連結：**  
     - 如果刪除檔案，但仍有指向該檔案的連結存在，就會產生**懸空指標 (Dangling Pointer)**，導致指向無效的檔案位置。  

3. **解決方案：**  
   - 使用**引用計數 (Reference Counter)：**  
     - 每個檔案有一個計數器，記錄指向該檔案的連結數量。  
     - 當引用計數減為 0 時，表示沒有任何連結指向該檔案，檔案即可安全刪除。  

---

### **一般圖目錄結構 (General-Graph Directory)**  

一般圖目錄允許目錄之間形成循環，結構更加靈活，但也引入了一些挑戰。  

1. **特性：**  
   - **允許循環 (May Contain Loops)：**  
     - 目錄結構可能包含循環，例如一個目錄指向自己或透過其他目錄間接形成環路。  
   - **無窮迴圈 (Infinite Loop)：**  
     - 若在循環中不慎進行搜尋，可能導致程式陷入無窮迴圈，無法完成操作。  

2. **問題：**  
   - **引用計數失效：**  
     - 循環會導致引用計數無法正確判斷是否可以刪除檔案，例如當兩個目錄互相引用時，引用計數永遠不為 0。  

3. **解決方案：**  
   - **垃圾回收 (Garbage Collection)：**  
     - 使用一種特定機制判斷當最後一個引用被刪除時，檔案所佔用的磁碟空間可以被重新分配。  
   - **循環檢測 (Cycle Detection)：**  
     - 在建立連結時執行檢測演算法，確保新的連結不會引入循環。  

---

無環圖目錄結構適用於需要嚴格避免循環的環境，而一般圖目錄則適合需要更多彈性的應用，但需額外的管理機制來處理循環問題，確保系統運行穩定。

### **檔案系統掛載 (File-System Mounting)**  

在使用檔案系統之前，必須先將其掛載到目錄結構中，以下是檔案系統掛載的主要概念：  

1. **掛載必要性：**  
   - 檔案系統在被訪問前，必須透過掛載 (Mounting) 來整合到作業系統的檔案目錄中。  

2. **掛載點 (Mount Point)：**  
   - 掛載點是檔案系統整合到目錄結構中的根路徑。例如，將一個未掛載的檔案系統掛載到 `/mnt/usb`。  

3. **掛載時機：**  
   - **開機時 (Boot Time)：**  
     - 系統啟動時，會自動掛載必要的檔案系統（如根檔案系統）。  
   - **執行時自動掛載 (Automatically at Run-Time)：**  
     - 根據需求，系統會在執行期間自動掛載檔案系統，例如插入 USB 裝置時。  
   - **執行時手動掛載 (Manually at Run-Time)：**  
     - 由使用者使用命令手動掛載檔案系統，例如 `mount` 指令。

---

### **檔案共享 (File Sharing)**  

檔案共享是多使用者系統中的重要功能，使多個使用者可以共同存取檔案：  

1. **共享的重要性：**  
   - 在多使用者系統中，檔案共享有助於協同工作和提高資源使用效率。  

2. **使用者識別：**  
   - **使用者 ID (User ID)：**  
     - 唯一標識每位使用者，並根據使用者設定檔案的存取權限與保護措施。  
   - **群組 ID (Group ID)：**  
     - 使用者可以被分配到一個群組中，允許同群組成員擁有檔案的共享存取權。  

3. **檔案的三種屬性：**  
   - **擁有者 (Owner)：**  
     - 定義檔案擁有者的權限，例如讀取、寫入和執行的特權。  
   - **群組 (Group)：**  
     - 根據擁有者的設定，允許群組成員存取檔案。  
   - **其他人 (Others)：**  
     - 非擁有者或群組成員的其他使用者，其存取權限也由擁有者設定。  

---

透過檔案系統掛載，檔案可以被整合進作業系統的目錄結構中；而檔案共享則依據使用者與群組權限，實現多使用者系統中的高效協作與資源共享。

### **存取控制與群組 (Access-Control and Groups)**  

存取控制機制用於確保檔案能夠根據使用者權限被正確存取。以下是相關內容的解釋：  

1. **存取控制清單 (ACL)：**  
   - 為每個檔案建立一個存取控制清單，列出哪些使用者或群組擁有哪些操作的權限。  
   - 在使用者請求存取檔案時，系統會檢查該操作是否符合 ACL 的定義。  

2. **存取模式 (Mode of Access)：**  
   - 檔案的存取模式包括：  
     - **讀取 (Read, R)**：允許查看檔案內容。  
     - **寫入 (Write, W)**：允許修改檔案內容。  
     - **執行 (Execute, X)**：允許執行檔案（例如程式）。  

3. **使用者分級與權限 (3 Classes of Users)：**  
   - 每個檔案分為三種使用者群組，分別對應不同的存取權限：  
     - **擁有者 (Owner Access)：**  
       - 擁有檔案的使用者，權限通常最大（RWX = 111 = 7）。  
     - **群組 (Group Access)：**  
       - 與檔案擁有者屬於相同群組的其他使用者，權限可能較少（RWX = 110 = 6）。  
     - **公眾 (Public, Others Access)：**  
       - 所有其他使用者，權限最少（RWX = 001 = 1）。  

---

### **檔案保護 (File Protection)**  

檔案保護用於防止檔案受到不當的存取或損壞。以下是檔案保護的重點：  

1. **控制權限 (Control Access)：**  
   - **檔案擁有者/建立者的控制權：**  
     - 檔案擁有者應該能夠決定哪些操作可以被執行，並由哪些人執行。  

2. **檔案的保護目標：**  
   - **防止物理損壞 (Reliability)：**  
     - 採用技術如 RAID（獨立磁碟冗餘陣列）來提高檔案的可靠性，減少因硬體故障導致的資料遺失。  
   - **防止不當存取 (Protection)：**  
     - 使用密碼或其他存取控制技術來保護檔案免受未經授權的使用者存取。  

---

ACL 和分級權限確保檔案能被正確地分享或保護，而檔案保護機制進一步增強了檔案的安全性與穩定性。

檔案系統結構：

- **檔案結構**  
  檔案是一種邏輯儲存單元，用於組織和管理相關的資訊集合。

- **邏輯儲存單元**  
  檔案是儲存和組織資料的基本單元，提供使用者一個可以理解和操作的邏輯介面。

- **相關資訊的集合**  
  檔案通常用來儲存某種相關的資訊，像是文字、圖片或程式碼。

- **檔案系統位於次級儲存設備（磁碟）上，並且組織成層次結構**  
  檔案系統是設計在次級儲存裝置（如硬碟或固態硬碟）上的一種邏輯架構，幫助管理資料的存取與儲存。

- **提供從邏輯儲存到物理儲存的映射**  
  它為使用者提供了一個友好的介面，將邏輯檔案結構與實際物理儲存設備之間的映射轉換處理。

- **高效且方便的存取磁碟資料**  
  檔案系統設計目的是讓資料可以方便地儲存、定位和檢索，提升存取效率和使用便利性。

- **記憶體與磁碟之間的 I/O 傳輸單位是區塊（blocks）**  
  在進行資料傳輸時，資料以區塊為單位進行交換，這是一種標準化的傳輸方式。

- **一個區塊由一個或多個扇區（sectors）組成**  
  區塊是磁碟儲存的基本單位，可以包含一個或多個扇區。

- **一個扇區的大小通常為 512 位元組（bytes）**  
  扇區是磁碟上最小的物理儲存單位，其大小通常是固定的，最常見的是 512 位元組。
  
  **分層檔案系統：**

- **應用程式層提供 API（應用程式介面）以執行檔案操作**  
  此層直接與使用者或應用程式互動，提供開啟（Open）、關閉（Close）、讀取（Read）等檔案操作功能。  
  - 例如：`read(fh, buf, size)`，該函數用於從檔案中讀取資料。

---

- **邏輯檔案系統層負責維護目錄結構與管理中繼資料（metadata）**  
  此層主要負責處理檔案的名稱和相關資訊：  
  - **翻譯檔案名稱至檔案編號、檔案控制代碼（file handle）和實際位置**  
    它使用檔案控制塊（File Control Blocks，UNIX 中稱為 inodes）來維護檔案資訊。  
  - **目錄管理**  
    管理目錄的結構，讓使用者能以層次化方式存取檔案。  
  - **保護機制**  
    提供對檔案的存取控制，確保資料的安全性和完整性。

---

- **檔案組織模組負責理解檔案的邏輯地址與物理區塊之間的對應關係**  
  - **將邏輯區塊編號（logical block #）轉換為物理區塊編號（physical block #）**  
    此層負責將檔案的邏輯結構映射到磁碟的實際儲存位置。  
  - **管理空間**  
    管理磁碟的空閒區域，確保儲存空間的有效分配。  
  - **磁碟配置**  
    決定資料應該如何在磁碟上配置，確保儲存效率和檢索速度。

---

**摘要：**  
分層檔案系統將檔案操作抽象化並分工，從使用者層到硬體層逐步處理檔案名稱、目錄結構、邏輯與物理地址轉換，確保檔案存取高效、安全且易於管理。

**分層檔案系統（續）：**

- **基本檔案系統（Basic File System）**  
  - 此層接收類似「檢索區塊 123」的指令，並將這些指令轉換為設備驅動程式可以處理的格式。  
  - 負責直接與設備驅動程式互動，提供基本的資料區塊讀取或寫入功能。

---

- **設備驅動程式（Device Drivers）管理 I/O 設備**  
  - 位於 I/O 控制層，負責處理與硬體設備的直接互動。  
  - 它根據檔案系統的需求發出具體的硬體操作指令。

---

- **具體操作範例：**  
  當系統接收到指令如「讀取 drive1 的第 72 磁柱、第 2 磁軌、第 10 扇區，並將資料載入記憶體位置 1060」，設備驅動程式會將這些需求轉換為硬體控制器所需的低階硬體指令。  
  - **硬體控制器** 進一步執行實際的磁碟操作，完成資料的存取。

---

**摘要：**  
分層檔案系統中的基本檔案系統和設備驅動程式共同協作，將高階的邏輯檔案操作逐步轉換為低階的硬體命令，實現從軟體到硬體的無縫銜接，並確保資料存取的準確性與效率。

**檔案系統的實現 – 磁碟上的結構**

---

- **在 API 層有系統呼叫（system calls），但它們的功能是如何實現的？**  
  檔案系統實現需要依賴磁碟上的結構（on-disk structures）和記憶體中的結構（in-memory structures）來支持檔案操作功能。

---

### **磁碟上的結構：**

1. **開機控制區塊（Boot Control Block）：**
   - 包含系統啟動作業系統所需的資訊。  
   - 當磁碟分區包含作業系統時，這一區塊是必要的。通常位於分區的第一個區塊。  
   - **範例：**
     - **UFS（Unix File System）**：開機區塊（boot block）。  
     - **NTFS**：分區開機區塊（partition boot sector）。

2. **分區控制區塊（Volume Control Block 或 Partition Control Block）：**
   - 儲存關於分區的詳細資訊：  
     - 區塊總數（Total # of blocks）。  
     - 空閒區塊數量（# of free blocks）。  
     - 區塊大小（block size）。  
     - 空閒區塊指標或陣列（free block pointers or array）。  
   - **範例：**
     - **UFS**：超級區塊（superblock）。  
     - **NTFS**：主檔案表（Master File Table，MFT）。

3. **目錄結構（Directory Structure）：**
   - 用於組織檔案的結構。  
   - 包含檔案名稱和相關的 inode 編號（在 UNIX 系統中）或主檔案表（在 NTFS 中）。  
   - 有助於快速定位檔案和檔案控制區塊（FCB）。

4. **檔案控制區塊（File Control Block, FCB）：**
   - 儲存關於檔案的詳細資訊：  
     - inode 編號（inode number）。  
     - 權限（permissions）。  
     - 檔案大小（size）。  
     - 創建、修改日期（dates）。  
   - **範例：**
     - **UFS**：將這些資訊存放在 inode 結構中。  
     - **NTFS**：將這些資訊存儲在主檔案表中，使用關聯式資料庫結構來管理。

---

**總結：**  
檔案系統在磁碟上透過分層的結構來管理檔案，包括開機控制區塊、分區控制區塊、目錄結構和檔案控制區塊等。這些結構共同支持檔案的存取、定位和操作，確保檔案系統運作高效且穩定。

**檔案系統的實現 – 記憶體中的結構**

---

### **記憶體中的結構：**

1. **記憶體中的分區表（In-Memory Partition Table）：**
   - 儲存有關每個已掛載分區的資訊。  
   - 提供作業系統關於分區的即時資訊，支持對分區的管理和操作。

---

2. **記憶體中的目錄結構（In-Memory Directory Structure）：**
   - 用於儲存最近存取的目錄資訊。  
   - 提高對目錄的存取速度，減少重複從磁碟讀取目錄的操作。

---

3. **系統範圍的開啟檔案表（System-Wide Open-File Table）：**
   - 包含每個已開啟檔案的檔案控制區塊（FCB）的副本。  
   - 此表是全系統共享的，用於追蹤系統中所有目前被開啟的檔案。

---

4. **每個程序的開啟檔案表（Per-Process Open-File Table）：**
   - 包含指向「系統範圍的開啟檔案表」中對應條目的指標（即檔案處理器/描述符）。  
   - 每個進程都有自己的這張表，用於管理進程自身開啟的檔案。

---

**總結：**  
記憶體中的檔案系統結構用於提升操作效率，減少與磁碟交互的頻率。這些結構（分區表、目錄結構、系統範圍和程序專屬的開啟檔案表）共同支撐檔案的即時存取和管理，確保檔案操作快速且有序地進行。

**目錄的實現**

---

### **1. 線性列表（Linear List）：**
- **特性：**  
  - 將檔案名稱以線性方式排列，並附帶指向資料區塊的指標。
  - 是最簡單的實現方法，容易編寫程式實現。
- **優點：**  
  - 結構簡單，實現容易。
- **缺點：**  
  - **執行效率低下**：搜尋時間為線性時間（linear search time）。  
  - 若檔案數量增加，搜尋時間將顯著延長。
- **改進方式：**  
  - 可使用鏈結串列（linked list）並按字母順序排序，或改用 **B+ 樹** 結構以優化搜尋效率。

---

### **2. 雜湊表（Hash Table）：**
- **特性：**  
  - 結合線性列表與雜湊資料結構，對檔案名稱進行雜湊運算，快速定位檔案。
- **優點：**  
  - 顯著降低目錄的搜尋時間（相較於線性列表）。  
- **缺點：**  
  - **碰撞問題（Collisions）**：當兩個檔案名稱的雜湊結果相同，將發生碰撞。需要設計碰撞解決機制（如鏈結法或開放定址法）。  
  - **適用範圍有限**：雜湊表僅適用於條目為固定大小（fixed size）的情況，否則會降低效率。

---

**總結：**  
目錄的實現方法主要有線性列表與雜湊表兩種。線性列表實現簡單但搜尋效率低；雜湊表搜尋快，但需要處理碰撞問題。針對具體需求選擇適合的實現方式，能平衡效率與實現複雜度。

**分配方法（Allocation Methods）**

分配方法指的是如何為檔案分配磁碟區塊。不同策略各有優缺點，常見的分配策略包括以下三種：

---

### **1. 連續分配（Contiguous Allocation）：**
- **原理：**  
  - 為檔案分配一個連續的磁碟區塊範圍。  
  - 檔案的所有資料存放在相鄰的區塊中。
- **優點：**  
  - **存取效率高**：由於資料在磁碟上是連續的，存取時不需要跳躍，讀取速度快。  
  - 適合順序讀取的大型檔案。  
- **缺點：**  
  - **外部碎片（External Fragmentation）：** 當空間分配不連續時，可能無法為新檔案分配足夠的連續空間。  
  - **檔案大小難以擴展**：若檔案需要增長，且後續區塊已被佔用，則需重新分配空間並移動檔案內容。

---

### **2. 鏈結分配（Linked Allocation）：**
- **原理：**  
  - 為檔案分配不連續的磁碟區塊，並用指標將這些區塊鏈結起來。  
  - 每個區塊內儲存資料以及指向下一個區塊的指標。
- **優點：**  
  - **無外部碎片問題**：可以使用不連續的空間來存放檔案。  
  - **適合檔案大小動態變化的情況**：檔案可以輕鬆增長或縮減。
- **缺點：**  
  - **存取效率低**：隨機存取檔案需要遍歷指標鏈，速度較慢。  
  - **額外儲存開銷**：每個區塊需儲存指標，減少了可用的儲存空間。  
  - 若指標損壞，可能導致資料丟失。

---

### **3. 索引分配（Indexed Allocation）：**
- **原理：**  
  - 為檔案建立一個索引區塊，索引區塊中包含指向檔案資料區塊的指標。  
  - 檔案的所有資料區塊由索引統一管理。
- **優點：**  
  - **隨機存取效率高**：可以直接透過索引找到檔案的特定區塊。  
  - 無外部碎片問題，區塊分配靈活。  
- **缺點：**  
  - **索引區塊的空間開銷**：需要額外的磁碟空間來儲存索引。  
  - 若檔案非常大，可能需要多層索引，增加管理的複雜性。

---

**總結：**  
- **連續分配** 適合需要高效順序存取的情況，但存在外部碎片問題。  
- **鏈結分配** 提供了分配靈活性，但隨機存取效率較低。  
- **索引分配** 平衡了靈活性和存取效率，適合檔案大小多樣的場景，但需要額外的索引空間。

**連續分配（Contiguous Allocation）**

---

### **特性：**
- 在連續分配中，每個檔案會占用一組**連續的磁碟區塊**。  
- 此方法在大多數情況下提供最佳的效能，特別是：
  - **順序存取（Sequential Access）**：連續存取檔案的區塊，效率極高。  
  - **隨機存取（Random Access）**：可以快速定位到特定區塊，存取時間短。  
- **實現簡單**：  
  - 只需記錄檔案的**起始位置（區塊號）**和**長度（區塊數量）**即可完成管理。

---

### **問題與限制：**

1. **外部碎片（External Fragmentation）：**  
   - 由於檔案需要連續空間，當磁碟上的空間分布變得不連續時，可能導致空閒空間無法被有效利用。

2. **尋找合適空間困難（Finding Space for File）：**  
   - 為新檔案分配連續空間可能需要進行大量的搜尋，特別是在磁碟空間接近飽和時。

3. **需預先知道檔案大小（Knowing File Size）：**  
   - 在分配空間時，需要事先確定檔案的大小，否則可能導致分配的空間不足或浪費。

4. **檔案無法增長（File Cannot Grow）：**  
   - 如果檔案需要增長，而後續的磁碟空間已被其他檔案占用，則檔案無法直接擴展，只能重新分配空間並移動檔案內容，效率低下。

---

**總結：**  
連續分配雖然能在順序和隨機存取方面提供優越的效能，且實現簡單，但其限制（如外部碎片、檔案大小預測困難和增長限制）使得它更適合大小固定且存取頻繁的檔案。

**連續分配的範例解說**

---

### **假設情境：**
磁碟分為多個區塊，每個區塊編號如下：  
**0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10**。

現有一個檔案名為 **"fileA"**，其大小為 **3 個區塊**。

---

### **分配過程：**
1. **尋找連續空間：**  
   檔案系統在磁碟中搜尋可以連續存放 3 個區塊的空間。例如，找到區塊 **5, 6, 7** 是連續且可用的。

2. **分配區塊：**  
   檔案系統將 **fileA** 儲存於區塊 **5, 6, 7** 中。

3. **記錄分配資訊：**  
   - 起始位置：**區塊 5**  
   - 長度：**3 個區塊**

---

### **存取檔案的情境：**

#### **順序存取（Sequential Access）：**
若需要讀取整個檔案 **fileA**，系統會從 **區塊 5** 開始，依次讀取 **區塊 6 和 7**，效率極高，因為這些區塊在磁碟上是連續排列的。

#### **隨機存取（Random Access）：**
若只需要讀取檔案的第 2 區塊（邏輯上是檔案的第二部分），系統直接計算：  
**起始區塊 5 + (需要的區塊索引 2 - 1) = 區塊 6**，並直接存取區塊 6，效率也非常高。

---

### **限制範例：**

#### **檔案增長的問題：**
若 **fileA** 後續需要擴展為 4 個區塊，則發現區塊 **8** 已被其他檔案占用，無法直接增長。此時，檔案系統可能需要：
1. 尋找新的連續 4 個區塊（例如，區塊 **2, 3, 4, 5**）。  
2. 將 **fileA** 從區塊 **5, 6, 7** 複製到新的空間，再釋放舊空間。  
這樣的操作會降低效能。

---

### **總結：**
**連續分配的優點：**
- 高效的順序與隨機存取。
- 結構簡單，易於管理。

**連續分配的缺點：**
- 容易出現外部碎片。
- 對於需要頻繁增長的檔案管理不便。

此方法適合大小固定的檔案，如音樂或視頻檔案。

**連續分配的範例解說**

---

### **假設情境：**
磁碟分為多個區塊，每個區塊編號如下：  
**0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10**。

現有一個檔案名為 **"fileA"**，其大小為 **3 個區塊**。

---

### **分配過程：**
1. **尋找連續空間：**  
   檔案系統在磁碟中搜尋可以連續存放 3 個區塊的空間。例如，找到區塊 **5, 6, 7** 是連續且可用的。

2. **分配區塊：**  
   檔案系統將 **fileA** 儲存於區塊 **5, 6, 7** 中。

3. **記錄分配資訊：**  
   - 起始位置：**區塊 5**  
   - 長度：**3 個區塊**

---

### **存取檔案的情境：**

#### **順序存取（Sequential Access）：**
若需要讀取整個檔案 **fileA**，系統會從 **區塊 5** 開始，依次讀取 **區塊 6 和 7**，效率極高，因為這些區塊在磁碟上是連續排列的。

#### **隨機存取（Random Access）：**
若只需要讀取檔案的第 2 區塊（邏輯上是檔案的第二部分），系統直接計算：  
**起始區塊 5 + (需要的區塊索引 2 - 1) = 區塊 6**，並直接存取區塊 6，效率也非常高。

---

### **限制範例：**

#### **檔案增長的問題：**
若 **fileA** 後續需要擴展為 4 個區塊，則發現區塊 **8** 已被其他檔案占用，無法直接增長。此時，檔案系統可能需要：
1. 尋找新的連續 4 個區塊（例如，區塊 **2, 3, 4, 5**）。  
2. 將 **fileA** 從區塊 **5, 6, 7** 複製到新的空間，再釋放舊空間。  
這樣的操作會降低效能。

---

### **總結：**
**連續分配的優點：**
- 高效的順序與隨機存取。
- 結構簡單，易於管理。

**連續分配的缺點：**
- 容易出現外部碎片。
- 對於需要頻繁增長的檔案管理不便。

此方法適合大小固定的檔案，如音樂或視頻檔案。

**鏈結分配（Linked Allocation）**

---

### **特性：**
1. **鏈結方式：**  
   - 每個檔案由一組磁碟區塊組成，這些區塊不必是連續的。  
   - 每個區塊儲存檔案資料的同時，還包含一個指向**下一個區塊**的指標。  
   - 當檔案結束時，指標為 **nil**，表示鏈結結束。

2. **無外部碎片（No External Fragmentation）：**  
   - 由於區塊不必連續，可以充分利用磁碟中的所有空閒區塊。  

---

### **優點：**
- **動態分配靈活：**  
  - 檔案可動態增長或縮減，僅需在空閒區塊中添加或移除區塊。
- **無外部碎片問題：**  
  - 可以充分利用磁碟中的零散空間，減少浪費。

---

### **缺點與問題：**

1. **隨機存取效率低：**  
   - 隨機存取檔案中的某一特定區塊，需要從鏈結的起點開始，逐一遍歷指標，直到找到目標區塊。  
   - 這種操作可能需要多次的磁碟輸入/輸出（I/O）以及磁碟尋道（disk seeks），效率較低。

2. **額外儲存空間：**  
   - 每個區塊需要額外的空間來儲存指標，這會減少可用的資料儲存空間。

3. **可靠性問題：**  
   - 如果某個區塊的指標受損（例如磁碟損壞），可能導致後續區塊無法存取，從而丟失部分或全部檔案資料。

---

### **範例解說：**
假設檔案 **fileA** 需要儲存 3 個區塊，其分配情況如下：  
- 區塊 7：儲存檔案資料，同時指向區塊 3。  
- 區塊 3：儲存檔案資料，同時指向區塊 5。  
- 區塊 5：儲存檔案資料，指向 **nil**，表示檔案結束。

檔案鏈結如下：  
**7 → 3 → 5 → nil**

#### **順序存取：**
從區塊 7 開始，依序讀取指向的區塊，直到結束，效率良好。

#### **隨機存取：**
若要存取第 3 區塊，系統需要依次遍歷區塊 7 和區塊 3，效率較低。

---

### **總結：**
- **適用情境：**  
  - 適合順序存取的檔案（如日誌檔案）。  
- **局限性：**  
  - 隨機存取效率差，且存在指標的儲存與可靠性問題。

**鏈結分配的範例解說**

---

### **假設情境：**

假設磁碟上有一系列的區塊編號如下：  
**0, 1, 2, 3, 4, 5, 6, 7, 8, 9**。

現在有一個檔案 **"fileA"**，它的資料需要佔用 **3 個區塊**，但這些區塊不需要是連續的。

---

### **分配過程：**

1. **分配磁碟區塊：**  
   - 檔案的資料會分散到不同的區塊上，並將這些區塊以鏈結的方式連接起來。
   - 假設 **fileA** 被分配到了區塊 **2、5、8**，那麼每個區塊的內容會如下：

   - **區塊 2**：儲存檔案的一部分資料，並包含一個指標指向**區塊 5**。  
   - **區塊 5**：儲存檔案的下一部分資料，並包含一個指標指向**區塊 8**。  
   - **區塊 8**：儲存檔案的最後一部分資料，並包含指標 **nil**，表示檔案結束。

2. **檔案鏈結：**  
   這樣檔案的區塊排列如下：  
   **2 → 5 → 8 → nil**

---

### **存取檔案的情境：**

#### **順序存取（Sequential Access）：**
- 當系統需要讀取檔案時，它會從 **區塊 2** 開始，然後根據區塊中的指標順序讀取 **區塊 5**，再讀取 **區塊 8**。
- 因為鏈結分配的區塊是按順序連接的，這樣的存取方式對順序讀取非常有效。

#### **隨機存取（Random Access）：**
- 若需要讀取檔案的第二部分（也就是存放在 **區塊 5** 的資料），系統需要先從 **區塊 2** 開始，然後根據指標跳到 **區塊 5**，才能找到需要的資料。
- 這樣的隨機存取效率較低，因為必須遍歷指標鏈來定位目標區塊。

---

### **優點與缺點：**

#### **優點：**
- **無外部碎片：** 因為檔案的資料不要求連續，磁碟上的空間可以有效利用，避免了外部碎片的問題。
- **動態擴展：** 檔案可以隨時增長，只需要將新的區塊鏈接到檔案的末尾，不需要移動現有的資料。

#### **缺點：**
- **隨機存取效率低：** 隨機存取時，系統需要依次遍歷指標鏈，直到找到目標區塊，這樣會增加磁碟的存取時間。
- **額外的空間開銷：** 每個區塊需要額外儲存指向下一區塊的指標，這會使得每個區塊的儲存空間增加。
- **可靠性問題：** 如果區塊中的指標被損壞或丟失，後續的區塊就無法存取，可能會導致檔案損壞。

---

### **總結：**
**鏈結分配** 是一種靈活的磁碟區塊分配方法，它解決了檔案大小動態變化的問題，但在隨機存取和空間管理上有其缺點，特別是在對效能要求高的情況下。

**索引分配（Indexed Allocation）**

---

### **特性：**
1. **索引區塊：**  
   每個檔案都有一個或多個**索引區塊**，這些索引區塊儲存了指向檔案資料區塊的指標。每個指標指向檔案的一個資料區塊，從而實現檔案資料的存取。

2. **檔案與資料區塊的關聯：**  
   索引區塊不需要儲存檔案資料本身，而是儲存資料區塊的指標。檔案資料的區塊可以不連續存儲在磁碟上，索引表負責將這些資料區塊按順序鏈接起來。

---

### **優點：**
- **隨機存取：**  
  索引分配可以快速定位到檔案的任何一個資料區塊，提供高效的隨機存取。只需要通過索引區塊來找到檔案的任意一個資料區塊，存取速度相對較快。

- **無外部碎片：**  
  由於資料區塊不需要連續分配，磁碟的空間可以更加有效地利用，減少了外部碎片問題。

---

### **缺點與問題：**

1. **索引區塊需要額外空間：**  
   每個檔案都需要一個索引區塊（或者多個索引區塊），這些索引區塊本身需要儲存指向檔案資料區塊的指標。這會佔用一定的磁碟空間，尤其是檔案很大時，索引區塊的數量會增多。

2. **多重索引區塊問題：**  
   當檔案的資料區塊非常多時，可能需要多個索引區塊來儲存所有的指標。這就會引發以下問題：
   - **索引區塊管理複雜：** 若檔案的資料區塊超過了一個索引區塊能儲存的範圍，則需要使用多個索引區塊。這樣的管理就變得更加複雜，並可能需要多層索引來處理，類似於分層索引。
   - **索引表空間浪費：** 當檔案的資料區塊較少時，索引區塊可能會有很多空閒空間，造成空間浪費。

---

### **範例解說：**

假設檔案 **fileA** 需要佔用 3 個區塊，這些區塊在磁碟上並不連續，而是分別位於區塊 **2、5、8**。

1. **建立索引區塊：**  
   檔案會有一個索引區塊，這個索引區塊儲存指向 **2、5、8** 這三個資料區塊的指標。

2. **檔案結構：**  
   - **索引區塊**：儲存指向 **區塊 2, 5, 8** 的指標。
   - **資料區塊 2**：儲存檔案的資料的一部分。
   - **資料區塊 5**：儲存檔案的資料的另一部分。
   - **資料區塊 8**：儲存檔案的最後一部分資料。

3. **存取檔案：**  
   - 若要隨機存取檔案的任何一部分，可以直接查找索引區塊，根據索引區塊的指標，快速定位到資料區塊 2、5、8，而不需要按順序遍歷區塊。

---

### **總結：**
**索引分配** 提供了隨機存取的高效性，並且不會像連續分配那樣遇到外部碎片問題。然而，索引區塊的額外空間需求和多重索引區塊的管理問題是它的主要缺點，尤其是在處理大檔案時會顯得更加複雜和低效。

**索引分配的範例解說**

---

### **假設情境：**

假設磁碟上有一系列的區塊編號如下：  
**0, 1, 2, 3, 4, 5, 6, 7, 8, 9**。

現在有一個檔案 **"fileA"**，需要佔用 **3 個資料區塊**，但這些區塊並不需要是連續的。假設 **fileA** 分別佔用了區塊 **2、5、8**。

---

### **分配過程：**

1. **建立索引區塊：**
   - 檔案系統會為 **fileA** 分配一個索引區塊。這個索引區塊儲存指向檔案資料區塊的指標。
   - 假設檔案 **fileA** 的資料儲存在區塊 **2、5、8**，那麼索引區塊將儲存這三個區塊的指標：**[2, 5, 8]**。

2. **檔案結構：**
   - **索引區塊**：儲存指向檔案資料的區塊的指標 **[2, 5, 8]**。
   - **資料區塊 2**：儲存檔案的第一部分資料。
   - **資料區塊 5**：儲存檔案的第二部分資料。
   - **資料區塊 8**：儲存檔案的第三部分資料。

---

### **存取檔案的情境：**

#### **順序存取（Sequential Access）：**
- 如果需要順序讀取整個檔案，系統會按照索引區塊中指標的順序，先讀取 **區塊 2**，接著讀取 **區塊 5**，最後讀取 **區塊 8**。由於索引區塊提供了指向資料區塊的具體位置，順序存取相對簡單且高效。

#### **隨機存取（Random Access）：**
- 假設使用者想要隨機存取檔案的第二部分（儲存在 **區塊 5**），系統會首先查找索引區塊，找到指向 **區塊 5** 的指標，然後直接存取該區塊，無需讀取其他區塊，這樣的隨機存取效率較高。

---

### **優點：**
1. **隨機存取高效：**  
   由於每個檔案都有一個索引區塊，這使得隨機存取某一資料區塊非常高效。只需查找索引表即可快速定位到資料區塊。
   
2. **無外部碎片：**  
   檔案的資料區塊可以不連續地分配在磁碟上，因此磁碟空間能夠更有效率地利用，並減少外部碎片問題。

---

### **缺點：**
1. **額外的空間開銷：**  
   每個檔案都需要一個索引區塊，這些索引區塊會佔用額外的磁碟空間。尤其是當檔案較大時，索引區塊的數量會增多，可能會造成額外的空間浪費。

2. **多重索引區塊的管理問題：**  
   當檔案的資料區塊非常多時，可能需要多個索引區塊來儲存所有的指標。這樣可能需要額外的管理機制（如多層索引表），使得檔案系統的管理變得更加複雜。

---

### **總結：**
在 **索引分配** 中，檔案系統為每個檔案分配一個索引區塊，索引區塊儲存指向資料區塊的指標，這樣可以實現高效的隨機存取和無外部碎片的優勢。然而，索引區塊的額外空間需求和多重索引區塊的管理問題則是它的主要缺點。

**空閒空間管理（Free Space）**

在檔案系統中，**空閒空間管理** 是一個非常重要的任務，因為它涉及如何有效地管理磁碟上未被使用的空間。系統需要記錄哪些區塊是空閒的，以便在檔案需要新增或擴展時能夠快速分配空間。常見的空閒空間管理方法有以下幾種：

---

### **1. 空閒區塊列表（Free-space List）**
- **空閒區塊列表** 是一種用來記錄所有空閒磁碟區塊的資料結構。當檔案系統需要為檔案分配空間時，會從空閒區塊列表中選擇一個或多個空閒區塊來儲存資料。
- 這些空閒區塊可以用不同的資料結構來管理，下面是幾種常見的方法。

---

### **2. 空間管理方法：**

#### **(1) 位圖（Bit Vector）**
- **位圖** 是一種利用位元來表示磁碟區塊是否被佔用的方法。每個位元對應一個磁碟區塊：
  - **0** 代表該區塊是空閒的。
  - **1** 代表該區塊已被佔用。
  
- 這種方法的優點是可以快速檢查某個區塊是否空閒，並且易於進行位元操作。
- 但缺點是位圖會消耗額外的空間來儲存每個區塊的狀態。

#### **(2) 鏈結列表（Linked List）**
- **鏈結列表** 是一種鏈接每個空閒區塊的資料結構。每個空閒區塊包含一個指向下一個空閒區塊的指標，形成一個鏈表。
- 這種方法的優點是當有空閒區塊釋放時，可以直接將它加入到鏈表中，並且不需要額外的空間來儲存區塊的狀態。
- 但缺點是需要遍歷整個鏈表才能找到一個空閒區塊，查找效率較低。

#### **(3) 分組（Grouping）**
- **分組** 是一種改進版的鏈結列表方法，通過將空閒區塊按一定的數量分組來加速查找過程。每個空閒區塊的指標會指向一個區塊組，這樣可以減少查找的時間。
- 當需要分配空間時，可以先找到空閒區塊的分組，再遍歷該組來找到具體的空閒區塊。

#### **(4) 計數法（Counting）**
- **計數法** 是基於連續分配的策略，專門用來管理**連續分配**的空閒區塊。這種方法會記錄連續的空閒區塊的數量，當需要分配一個檔案時，可以快速地找到一塊足夠大的連續空間來儲存資料。
- 當空間釋放時，會更新計數，並將空閒區塊合併成一個更大的連續區塊。

---

### **總結：**

- **位圖** 主要用於管理空閒區塊，適合於空間大小不一的情況。
- **鏈結列表** 用於將空閒區塊按鏈結方式管理，方便動態釋放和分配空間，但查找效率較低。
- **分組** 可以加速鏈結列表的查找過程，適用於需要快速查找的場景。
- **計數法** 用於**連續分配**的空間管理，特別適合於檔案系統需要大塊連續空間時。

這些方法各有優缺點，實際應用中常根據檔案系統的需求來選擇合適的空間管理方法。

**空閒空間管理（Free-Space Management）**

空閒空間管理是檔案系統中非常重要的一個部分，它負責管理磁碟上哪些區塊是可用的（即空閒區塊），哪些區塊已經被檔案佔用。常見的管理方法之一是使用**位元圖（Bit Vector）**或**位圖（Bit Map）**，它是一種用來表示磁碟區塊是否被佔用的資料結構。

---

### **位元圖（Bit Vector）**

位元圖（Bit Vector）是一個由位元組成的資料結構，每個位元對應一個磁碟區塊，並通過 0 或 1 來表示該區塊的狀態：
- **0**：表示該區塊是空閒的。
- **1**：表示該區塊已被佔用。

#### **範例解釋：**

假設我們有一個磁碟，其大小為 **230 字節（1 Gbytes）**，並且每個區塊的大小為 **212 字節（4 Kbytes）**。我們可以根據磁碟大小和區塊大小計算出需要多少個位元來表示空閒區塊的狀態：

1. **計算區塊數量：**
   - 磁碟的總大小為 **230 字節**，每個區塊的大小為 **212 字節**。
   - 所以，磁碟上總共有的區塊數量為：  
     \[
     \frac{230}{212} = 218 \text{個區塊}
     \]

2. **位元數量：**
   - 由於每個區塊需要一個位元來表示它的狀態（空閒或佔用），所以需要 **218 位**來表示磁碟上的所有區塊。
   - **218 位元**對應的存儲空間為：  
     \[
     218 \div 8 = 27.25 \text{字節} \quad \text{（大約是 32 Kbytes）}
     \]
   - 因此，**位元圖**會佔用約 **32 Kbytes** 的空間來管理所有的空閒區塊。

#### **位元圖的優勢：**
- **簡單高效：**  
  位元圖結構簡單，能夠有效地記錄每個區塊的使用情況，並且可以快速查找某個區塊是否空閒。

- **適合查找連續空閒區塊：**  
  透過位元圖，我們可以很容易地找到一段連續的空閒區塊。例如，如果位元圖顯示出一段連續的 **0**（空閒區塊），那麼我們就可以直接分配這段連續區塊來存儲檔案。

#### **範例：**
假設我們有一個位元圖如下：

```
11101011111111111111000
```

這表示磁碟上有一段區塊的使用情況：
- 前面的 **1** 表示這些區塊已被佔用。
- 中間的 **0** 表示這些區塊是空閒的。

透過這段位元圖，我們可以很容易地找到空閒區塊所在的位置，並且可以看到一段連續的空閒區塊。比如，在這個範例中，最後一段的連續 **0** 可以用來分配一個檔案，這樣可以避免碎片化。

---

### **缺點：**
1. **需要額外的空間：**  
   雖然位元圖結構簡單，但是它會消耗額外的空間來儲存每個區塊的狀態。若磁碟非常大，則位元圖的大小也會變得很大。

2. **位元圖更新：**  
   當區塊被釋放或分配時，位元圖需要更新，這也需要一定的時間。

---

### **總結：**
位元圖（Bit Vector）是一種簡單有效的空閒空間管理方法，可以快速檢查磁碟區塊的使用情況，並支持有效地找到連續的空閒區塊來分配檔案。雖然它需要額外的空間來儲存每個區塊的狀態，但在許多情況下，這種方法仍然是非常有效的。


**空閒空間管理（續）**

在檔案系統中，空閒空間的管理方法有多種，其中包括鏈結列表、分組法和計數法等。這些方法各有優缺點，適用於不同的情況。以下是這些方法的詳細解釋：

---

### **1. 鏈結列表（Linked List）**

- **概念：** 鏈結列表是將所有空閒區塊以鏈結方式連接起來，每個空閒區塊包含一個指向下一個空閒區塊的指標。這樣的結構可以方便地管理空閒區塊，當某個區塊被釋放時，會將它加到鏈表的開頭。

- **優點：**
  - **無空間浪費：** 鏈結列表只需要儲存空閒區塊的指標，不需要額外的空間來記錄每個區塊的使用情況，因此不會浪費空間。
  
- **缺點：**
  - **無法輕易獲得連續空間：** 因為區塊是以鏈結的方式存在，且可能是散佈在磁碟的各個位置，所以難以直接找到一個連續的空閒區塊來存儲需要連續空間的檔案。
  - **遍歷鏈表可能效率低：** 若需要查找空閒區塊，系統必須遍歷整個鏈結列表，這可能會造成較高的查找開銷。
  - **可靠性問題：** 如果鏈表中的某個指標丟失或損壞，可能會導致無法找到空閒區塊，影響系統的穩定性。

---

### **2. 分組法（Grouping）**

- **概念：** 分組法是一種改進版的鏈結列表，它通過將多個空閒區塊的指標組合在一起來加速查找過程。每個分組區塊會儲存指向 **n** 個空閒區塊的指標，並將指向下一個分組區塊的指標放在最後。

- **運作方式：**
  - 每個分組區塊有 **n** 個指標，其中前 **(n-1)** 個指標指向空閒區塊，而最後一個指標指向下一個分組區塊。
  - 當一個空閒區塊被分配後，會更新相應的指標。
  
- **優點：**
  - **提高查找效率：** 由於每個分組儲存多個空閒區塊的指標，這樣查找空閒區塊時，會比普通的鏈結列表更有效率。
  
- **缺點：**
  - **還是無法輕易取得連續區塊：** 儘管分組方法加速了查找過程，但如果需要一大段連續空間，這種方法依然無法提供很好的解決方案。

---

### **3. 計數法（Counting）**

- **概念：** 計數法是用來管理連續空閒區塊的一種方法。它會記錄一段連續的空閒區塊的起始位置以及這段區塊的長度。這樣，當需要分配檔案時，系統可以快速地找到一段連續的空閒區塊來儲存檔案。

- **運作方式：**
  - 系統會記錄**第一個空閒區塊的地址**以及**連續空閒區塊的數量**。
  - 例如，**(2, 3)** 表示區塊 **2、3、4** 是連續的空閒區塊，這樣可以一次性分配這段連續空間。
  - 另外，**(17, 5)** 表示從 **區塊 17** 開始的 **5 個連續區塊**（即區塊 17、18、19、20、21）是空閒的，可以用來儲存檔案。

- **優點：**
  - **適合連續分配的情況：** 計數法特別適合用於處理需要連續空間的檔案，這樣可以高效地利用磁碟空間並減少碎片。
  - **簡單高效：** 只需要記錄起始區塊和連續空閒區塊的數量，對於系統來說操作簡單且高效。

- **缺點：**
  - **不適合處理非連續檔案：** 計數法僅適用於連續分配，如果需要處理非連續空間，則無法提供優化。

---

### **總結：**

- **鏈結列表** 適合無空間浪費的情況，但無法輕易找到連續空間，且遍歷效率較低。
- **分組法** 改善了鏈結列表的查找效率，但仍無法有效處理連續空間的需求。
- **計數法** 適合處理需要大量連續空間的情況，但對於非連續分配的檔案則無法提供有效的解決方案。

選擇適合的空閒空間管理方法需要根據檔案系統的需求來進行權衡。