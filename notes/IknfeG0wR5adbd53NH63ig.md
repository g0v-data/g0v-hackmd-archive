Chapter 3: Processes
作業系統執行各種程序：
- **批次系統** - 作業（Jobs）
- **分時系統** - 使用者程式或任務（Tasks）

教科書幾乎將「作業」（job）和「程序」（process）這兩個術語互換使用。
- **程序** - 是正在執行的程式；程序執行必須以**順序**方式進行。

程序包含多個部分：
- **程式碼**，也稱為文字段（text section）
- 當前活動，包括**程式計數器**（program counter）、**處理器暫存器**（processor registers）
- 包含暫時資料的**堆疊**（stack）
  - 函式參數、返回地址、局部變數
- 包含全局變數的**資料段**（data section）
- 包含在執行時期動態分配的記憶體的**堆**（heap）

- **程式**是被動實體，存儲在磁碟上（可執行檔案），而**程序**是**主動**的。
- 當可執行檔案被加載到記憶體中時，程式變成程序。
- 程式的執行可通過 GUI 的滑鼠點擊、命令行輸入程式名稱等方式啟動。
- 一個程式可以是多個程序。
  - 考慮多個使用者執行相同程式的情況。
 Process in Memory
 ![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_94c2d1022b492ee1356147226a544db2.PNG)
程序狀態

當一個程序執行時，它會改變狀態：

- **new（新建）**: 程序正在被創建
- **running（執行）**: 指令正在被執行
- **waiting（等待）**: 程序在等待某些事件發生
- **ready（就緒）**: 程序正在等待被分配到處理器
- **terminated（終止）**: 程序已完成執行
Diagram of Process State
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_5c799f6cde5e00dd919f71984b69608b.PNG)
**程序控制塊 (PCB)**

與每個程序相關的資訊  
（也稱為任務控制塊）

- **程序狀態** – 執行中、等待中等
- **程式計數器** – 下一條要執行的指令的位置
- **CPU 暫存器** – 所有與程序相關的暫存器內容
- **CPU 排程資訊** – 優先級、排程隊列指標
- **記憶體管理資訊** – 分配給程序的記憶體
- **記帳資訊** – 已使用的 CPU 時間、從開始執行以來經過的時間、時間限制
- **I/O 狀態資訊** – 分配給程序的 I/O 設備、打開的文件列表
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_5449d343f5086af6f485442b3f258ef6.PNG)

CPU Switch From Process to Process
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_1d99625e03b0f051a5fcbb2ef3e0b51f.PNG)
**程序排程**

最大化 CPU 使用率，快速切換程序到 CPU 上以進行**時間共享**。

- **程序排程器**從可用的程序中選擇下一個要在 CPU 上執行的程序。
- 排程器維護程序的排程隊列：
  - **作業隊列**（Job queue）– 系統中所有程序的集合
  - **就緒隊列**（Ready queue）– 位於主記憶體中，準備執行並等待執行的程序集合
  - **設備隊列**（Device queues）– 等待 I/O 設備的程序集合
- 程序在不同的隊列之間進行遷移。
就緒隊列（Ready Queue）和各種 I/O 設備隊列
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_74009599afcb52d5ab4f095e928dd925.PNG)
**程序排程的表示**
排隊圖表示隊列、資源、流程
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_905afd1972c046e20cd09705a2b9557f.PNG)
**短期排程器**（或 CPU 排程器）– 選擇應該下一個執行的程序並分配 CPU。  
有時它是系統中唯一的排程器。

- **短期排程器**會頻繁地被調用（以毫秒為單位）（必須快速）。
  
**長期排程器**（或作業排程器）– 選擇哪些程序應該被放入就緒隊列。  
**長期排程器**調用的頻率較低（以秒或分鐘為單位）（可以較慢）。

**長期排程器**控制多程式設計的程度。
**增加中期排程**

如果需要降低多程式設計的程度，可以添加**中期排程器**。  
中期排程器會將程序從記憶體中移除，儲存到磁碟，然後再從磁碟中讀取以繼續執行，這個過程稱為**交換（swapping）**。

程序可描述為：
- **I/O 密集型程序** – 花費更多時間在 I/O 操作上，而非計算，具有許多短暫的 CPU 執行週期。
- **CPU 密集型程序** – 花費更多時間在計算上，具有少數但較長的 CPU 執行週期。

**長期排程器**的目標是保持良好的程序混合。
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_cb8e81c3689e645d6b9c49c4ce91d769.PNG)
**上下文切換**

當 CPU 切換到另一個程序時，系統必須保存舊程序的狀態，並通過上下文切換加載新程序的已保存狀態。

- 程序的上下文表示在**程序控制塊 (PCB)** 中。
- 上下文切換時間是一種**開銷**；在切換期間，系統無法執行有用的工作。
- 作業系統和 PCB 越複雜，**上下文切換**所需的時間越長。
- 上下文切換時間依賴於**硬體支援**。
- 有些硬體提供每個 CPU 的多組暫存器 ➔ 可以一次加載多個上下文。
**對程序的操作**

系統必須提供以下機制：
- **程序創建**，
- **程序終止**，
- 等等，具體內容如下。

### 程序創建

父程序創建子程序，子程序又可以創建其他程序，形成一棵程序樹。  
通常，程序通過**程序識別碼（pid）**來識別和管理。

**資源共享選項**：
- 父程序和子程序共享所有資源。
- 子程序共享父程序資源的子集。
- 父程序和子程序不共享任何資源。

**執行選項**：
- 父程序和子程序同時執行。
- 父程序在子程序終止之前等待。
**地址空間**

- **子程序**是父程序的**副本**。
- 子程序有一個程式載入到它的地址空間中。

### UNIX 範例

- **fork()** 系統調用用於創建新程序。
- **exec()** 系統調用在 `fork()` 之後使用，用於將程序的記憶體空間替換為新程序。
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_28a26586f473b3a5c10f095cf0b17acc.PNG)
**程序終止**

- 程序執行最後一條語句，然後通過 `exit()` 系統調用請求作業系統刪除自己。
- 通過 `wait()` 將狀態數據從子程序返回給父程序。
- 作業系統會釋放程序的資源。
- 父程序可以使用 `abort()` 系統調用終止子程序的執行。這樣做的原因包括：
  - 子程序超出了分配的資源。
  - 分配給子程序的任務不再需要。
一些作業系統不允許子程序存在於其父程序已終止的情況下。如果一個程序終止，那麼它的所有子程序也必須被終止，這稱為**級聯終止**（cascading termination）。所有的子程序、孫程序等都會被終止。

- 終止是由作業系統啟動的。
- 父程序可以使用 `wait()` 系統調用等待子程序的終止。
- 如果沒有父程序在等待（未調用 `wait()`），則該程序成為**僵屍程序**（zombie）。
- 如果父程序在未調用 `wait()` 的情況下終止，則該程序成為**孤兒程序**（orphan）。
### 程序終止

1. **執行最後語句**：程序執行完最後一條語句後，通過 `exit()` 系統調用請求作業系統刪除自己。
  
2. **返回狀態數據**：狀態數據通過 `wait()` 從子程序返回給父程序。

3. **資源釋放**：作業系統會釋放程序所占用的資源。

4. **父程序終止子程序**：父程序可以使用 `abort()` 系統調用終止子程序的執行，這樣做的原因包括：
   - 子程序超出了分配的資源。
   - 分配給子程序的任務不再需要。

5. **級聯終止**：某些作業系統不允許子程序在其父程序已終止的情況下存在。如果一個程序終止，那麼它的所有子程序也必須被終止，這稱為**級聯終止**（cascading termination），即所有的子程序、孫程序等都會被終止。

6. **由作業系統啟動**：程序的終止由作業系統發起。

7. **等待終止**：父程序可以使用 `wait()` 系統調用等待子程序的終止。

8. **僵屍程序**：如果沒有父程序在等待（未調用 `wait()`），則該程序成為**僵屍程序**（zombie）。

9. **孤兒程序**：如果父程序在未調用 `wait()` 的情況下終止，則該程序成為**孤兒程序**（orphan）。
### 進程間通信（Interprocess Communication, IPC）

系統中的進程可以是獨立的或是合作的。合作進程可以影響其他進程，或被其他進程影響，包括共享數據。

#### 合作進程的原因：
- **信息共享**：允許進程之間共享數據。
- **計算加速**：通過並行處理提高計算速度。
- **模塊化**：將複雜的問題分解為更小的、易於管理的部分。
- **便利性**：提高系統的使用效率和便利性。

合作進程需要進程間通信（IPC），主要有以下兩種模型：

### IPC 的兩種模型
1. **共享記憶體**（Shared Memory）：多個進程可以訪問同一段記憶體空間以進行數據共享。
2. **消息傳遞**（Message Passing）：進程之間通過傳送和接收消息來進行通信。

### 通信模型
- **(a) 消息傳遞**：進程通過發送和接收消息來交流。
- **(b) 共享記憶體**：進程通過訪問共享的記憶體區域來交流。

這兩種模型各有優缺點，適用於不同的應用場景和需求。
![](https://s3-ap-northeast-1.amazonaws.com/g0v-hackmd-images/uploads/upload_7707350344a229ebf463d797aaa5c545.PNG)
